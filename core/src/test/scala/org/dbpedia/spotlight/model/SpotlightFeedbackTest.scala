package org.dbpedia.spotlight.model

import org.junit.runner.RunWith
import org.scalatest.junit.JUnitRunner
import org.scalatest.FlatSpec
import org.scalatest.matchers.ShouldMatchers
import java.net.URL
import org.dbpedia.spotlight.exceptions.InputException
import org.dbpedia.spotlight.log.SpotlightLog
import java.io.{File, FileOutputStream, ByteArrayInputStream}
import scala.io.Source

/**
 * This ScalaTest test the SpotlightFeedback abstract type validation, standardization and use.
 *
 * @author Alexandre CanÃ§ado Cardoso - accardoso
 */

@RunWith(classOf[JUnitRunner])
class SpotlightFeedbackTest extends FlatSpec with ShouldMatchers {

  "The SpotlightFeedback constructor using HTTP like entries" should "construct a correct SpotlightFeedback instance when only the obligatory fields are informed" in{
    val usingHttpLikeEntriesConstructedFeedback = new SpotlightFeedback("Berlin is capital of Germany", "Berlin", "Berlin", 1,
      "correct", "spotlight_lucene spotlight_statistical", "false")
    val reference = new SpotlightFeedback(new Text("Berlin is capital of Germany"), new DBpediaResource("Berlin"),
      new SurfaceForm("Berlin"), 1, "correct", List[String]("spotlight_lucene", "spotlight_statistical"), false)

    usingHttpLikeEntriesConstructedFeedback.toString() should be === reference.toString()
  }

  it  should "construct a correct SpotlightFeedback instance when all fields are informed" in{
    val usingHttpLikeEntriesConstructedFeedback = new SpotlightFeedback("Berlin is capital of Germany", "http://www.berlin.de",
      "news" , "Berlin", "Berlin", 1, "correct", "spotlight_lucene spotlight_statistical", "false", "english")
    val reference = new SpotlightFeedback(new Text("Berlin is capital of Germany"), new URL("http://www.berlin.de"),
      "news", new DBpediaResource("Berlin"), new SurfaceForm("Berlin"), 1, "correct", List[String]("spotlight_lucene", "spotlight_statistical"),
      false, "english")

    usingHttpLikeEntriesConstructedFeedback.toString() should be === reference.toString()
  }

  "The SpotlightFeedback constructor for obligatory fields" should "construct a correct SpotlightFeedback" in {
    val obligatoryFieldsConstructedFeedback = new SpotlightFeedback(new Text("Berlin is capital of Germany"), new DBpediaResource("Berlin"),
      new SurfaceForm("Berlin"), 1, "correct", List[String]("spotlight_lucene", "spotlight_statistical"), false)
    val text: Text = new Text("Berlin is capital of Germany")
    val allFieldsConstructedFeedback = new SpotlightFeedback(text, SpotlightFeedback.createDefaultDocUrl(text), "",
      new DBpediaResource("Berlin"), new SurfaceForm("Berlin"), 1, "correct", List[String]("spotlight_lucene", "spotlight_statistical"),
      false, "")

    obligatoryFieldsConstructedFeedback.toString() should be === allFieldsConstructedFeedback.toString()
  }

  "A SpotlightFeedback" should "be standardize" in{
    val feedback = new SpotlightFeedback("Berlin is capital of Germany", "", "news" , "Berlin", "Berlin", 1, "correct", 
                                         "spotlight_lucene", "false", "english")

    feedback.getFeedback() should be === feedback.getFeedback().toLowerCase
    feedback.getSystems().mkString(" ") should be === feedback.getSystems().mkString(" ").toLowerCase
    feedback.getDiscourseType() should be === feedback.getDiscourseType().toLowerCase
    feedback.getLanguage() should be === feedback.getLanguage().toLowerCase
  }

  it should "be validated" in {
    var invalidSpotlightFeedback: SpotlightFeedback = null
    try{
      invalidSpotlightFeedback = new SpotlightFeedback(new Text(""), new URL("http://"), "", new DBpediaResource(""),
                                                       new SurfaceForm(""), -1, "", List[String](), false, "")
    } catch {
      case e: InputException => //The expected exception for a invalid entry
    }
    invalidSpotlightFeedback should be (null)
  }

  "The document url" should "be auto-generated if it was not informed" in {
    (((new SpotlightFeedback(new Text("Berlin is capital of Germany"), new URL("http://"), "", new DBpediaResource("Berlin"),
      new SurfaceForm("Berlin"), 1, "correct", List[String]("user"), true, "")).getDocUrl()).toString()) should not be === ("")
  }

  "The method to create a default url from the text" should "create a valid/correct url" in {
    val text: Text = new Text("Berlin is capital of Germany")
    val autoGeneratedUrl = SpotlightFeedback.createDefaultDocUrl(text)

    var validUrl: Boolean = false
    try {
      new URL(autoGeneratedUrl.toString)
      validUrl = true
    }catch {
      case e: Exception => //validUrl is already false
    }
    validUrl should be === true

    autoGeneratedUrl.toString.startsWith("http://") should be === true

    autoGeneratedUrl.toString should be === (SpotlightFeedback.getDefaultDocURLRoot() + text.hashCode())
  }

  "The validation method" should "identify all invalid entries" in {
    var success: Boolean = false
    //Only text invalid
    try{
      SpotlightFeedback.validate(new Text(""), new DBpediaResource("Berlin"),
                                 new SurfaceForm("Berlin"), 1, "correct", List[String]("user"), true)
    } catch {
      case e: InputException => success = true
    }
    success should be === true

    success = false
    //Only entity invalid
    try{
      SpotlightFeedback.validate(new Text("Berlin is capital of Germany"), new DBpediaResource(""),
                                 new SurfaceForm("Berlin"), 1, "correct", List[String]("user"), true)
    } catch {
      case e: InputException => success = true
    }
    success should be === true

    success = false
    //Only surface form invalid
    try{
      SpotlightFeedback.validate(new Text("Berlin is capital of Germany"), new DBpediaResource("Berlin"),
                                 new SurfaceForm(""), 1, "correct", List[String]("user"), true)
    } catch {
      case e: InputException => success = true
    }
    success should be === true

    success = false
    //Only offset invalid
    try{
      SpotlightFeedback.validate(new Text("Berlin is capital of Germany"), new DBpediaResource("Berlin"),
                                 new SurfaceForm("Berlin"), -1, "correct", List[String]("user"), true)
    } catch {
      case e: InputException => success = true
    }
    success should be === true

    success = false
    //Only feedback invalid
    try{
      SpotlightFeedback.validate(new Text("Berlin is capital of Germany"), new DBpediaResource("Berlin"),
                                 new SurfaceForm("Berlin"), 1, "", List[String]("user"), true)
    } catch {
      case e: InputException => success = true
    }
    success should be === true

    success = false
    //Only systems invalid (and setted as manual)
    try{
      SpotlightFeedback.validate(new Text("Berlin is capital of Germany"), new DBpediaResource("Berlin"),
                                 new SurfaceForm("Berlin"), 1, "correct", List[String](), true)
    } catch {
      case e: InputException => success = true
    }
    success should be === true
    //Only systems invalid (and setted as not manual)
    try{
      SpotlightFeedback.validate(new Text("Berlin is capital of Germany"), new DBpediaResource("Berlin"),
        new SurfaceForm("Berlin"), 1, "correct", List[String](), false)
    } catch {
      case e: InputException => success = true
    }
    success should be === true
  }

  "Feedback possibilities" should "contain at least \"correct\" and \"incorrect\"" in {
    SpotlightFeedback.getAllFeedbackPossibilities().contains("correct") should be === true
    SpotlightFeedback.getAllFeedbackPossibilities().contains("incorrect") should be === true  
  }

  "The mkString method" should "make a String with all attributes in the correct format" in {
    val feedback = new SpotlightFeedback(new Text("Berlin is capital of Germany"), new URL("http://www.berlin.de"),
                                         "news", new DBpediaResource("Berlin"), new SurfaceForm("Berlin"), 1, "correct",
                                         List[String]("spotlight_lucene", "spotlight_statistical"), false, "english")

    feedback.mkString("\t") should be === "Berlin is capital of Germany\thttp://www.berlin.de\tnews\thttp://dbpedia.org/resource/Berlin\tBerlin\t1\tcorrect\tspotlight_lucene spotlight_statistical\tfalse\tenglish"
  }

  "The toString method" should "return a String with all attributes in the correct format" in {
    val feedback = new SpotlightFeedback(new Text("Berlin is capital of Germany"), new URL("http://www.berlin.de"),
      "news", new DBpediaResource("Berlin"), new SurfaceForm("Berlin"), 1, "correct",
      List[String]("spotlight_lucene", "spotlight_statistical"), false, "english")

    feedback.toString() should be === "SpotlightFeedback[Berlin is capital of Germany | http://www.berlin.de | news | http://dbpedia.org/resource/Berlin | Berlin | 1 | correct | spotlight_lucene spotlight_statistical | false | english]"
  }

  "The toDBpediaResourceOccurrence method" should "conver correctly to a valid DBpediaResourceOccurrence" in {
    val feedback = new SpotlightFeedback(new Text("Berlin is capital of Germany"), new URL("http://www.berlin.de"),
      "news", new DBpediaResource("Berlin"), new SurfaceForm("Berlin"), 1, "correct",
      List[String]("spotlight_lucene", "spotlight_statistical"), false, "english")

    val expected = new DBpediaResourceOccurrence(new DBpediaResource("Berlin"), new SurfaceForm("Berlin"), new Text("Berlin is capital of Germany"), 1)
    feedback.toDBpediaResourceOccurrence().toString() should be === expected.toString()
  }

  "The SpotlightFeedback number of fields at constant/value numOfFields" should "be the total of attributes (including obligatory and optional ones)" in {
    val allAttributes: Array[String] = (new SpotlightFeedback(new Text("Berlin is capital of Germany"), new URL("http://www.berlin.de"),
      "news", new DBpediaResource("Berlin"), new SurfaceForm("Berlin"), 1, "correct",
      List[String]("spotlight_lucene", "spotlight_statistical"), false, "english")).mkString("\t").split("\t")

    SpotlightFeedback.nunOfFields should be === allAttributes.length
  }


  /* Tests for the automatic systems ids list management */
  SpotlightFeedbackTest.originalAutomaticSystemsIds = SpotlightFeedback.getAutomaticSystemsIds()

  "The automatic systems ids manager" should "add a new system id" in {
    val systemsBefore = SpotlightFeedback.getAutomaticSystemsIds()
    //Run the add interface to register newSystem 
    SpotlightFeedbackTest.runSpotlightFeedbackMain(SpotlightFeedbackTest.addOptionCode + SpotlightFeedbackTest.enter +
                             SpotlightFeedbackTest.newSystem + SpotlightFeedbackTest.enter + "y")
    //The automatic systems ids after registration should be equal to: systemsBefore + {newSystem}
    SpotlightFeedback.getAutomaticSystemsIds() should be === (systemsBefore :+ SpotlightFeedbackTest.newSystem)
  }
  
  it should "not add an invalid system id" in {
    val systemsBefore = SpotlightFeedback.getAutomaticSystemsIds()
    //Run the add interface to register newSystem
    var exception: Boolean = false
    try{
      SpotlightFeedbackTest.runSpotlightFeedbackMain(SpotlightFeedbackTest.addOptionCode + SpotlightFeedbackTest.enter + "Unit-Test SystemId.tmp" +
                                                     SpotlightFeedbackTest.enter + "y")
      //exception is already false
    }catch{
      case e: IllegalArgumentException => exception = true
    }
    //The invalid systems id should be refused, ...
    exception should be === true
    //... so the automatic systems should not be modified
    SpotlightFeedback.getAutomaticSystemsIds() should be === systemsBefore
  }

  it should "remove the requested system id" in {
    val systemsBefore = SpotlightFeedback.getAutomaticSystemsIds()
    //Run the removal interface to register newSystem 
    SpotlightFeedbackTest.runSpotlightFeedbackMain(SpotlightFeedbackTest.removeOptionCode + SpotlightFeedbackTest.enter +
                             SpotlightFeedbackTest.newSystem + SpotlightFeedbackTest.enter + "y")
    //The automatic systems ids after removal should be equal to: systemsBefore - {newSystem}
    SpotlightFeedback.getAutomaticSystemsIds() should be === systemsBefore.filterNot(_.equals(SpotlightFeedbackTest.newSystem))
  }

  it should "list the systems ids" in {
    //Define an output stream that will print to the testOutputStream file
    val testOutputStream: File = new File("AuthenticationTest.out.tmp")
    val outputStream = new FileOutputStream(testOutputStream)
    //In this block the stdout is replaced by outputStream
    Console.withOut(outputStream){
      SpotlightFeedbackTest.runSpotlightFeedbackMain(SpotlightFeedbackTest.listOptionCode)
    }
    val output: String = Source.fromFile(testOutputStream).getLines().mkString("\n")
    testOutputStream.delete should be === true
    output.endsWith(SpotlightFeedback.getAutomaticSystemsIds().mkString("\n")) should be === true
  }

  "At the end of this test the automatic systems ids list" should "be at the original state" in {
    //Print what was the original, because in case of error the developer can manually fix it
    SpotlightLog.info(this.getClass, "The original automatic systems ids lit was: %s", SpotlightFeedbackTest.originalAutomaticSystemsIds.toString())
    //Verify if the current automatic systems ids list is the same then the original, as it should.
    SpotlightFeedbackTest.originalAutomaticSystemsIds should be === SpotlightFeedback.getAutomaticSystemsIds()
  }

}

object SpotlightFeedbackTest {
  var originalAutomaticSystemsIds: List[String] = null
  val newSystem = "spotlight_feedback_test_system_id1_tmp"
  val enter: Char = 13

  /* The management interface operations codes */
  val addOptionCode = "1"
  val removeOptionCode = "2"
  val listOptionCode = "3"

  /* Run Authentication.main with the informed argument array and using a not standard input an output */
  private def runSpotlightFeedbackMain(userInput: String) {
    //Define an input stream with the userInput
    val inputStream = new ByteArrayInputStream(userInput.getBytes())   
    //In this block the stdin is replaced by inputStream
    Console.withIn(inputStream){
      //Run the Authentication main with the informed array of arguments and using the above defined stream in the place of the standard ones
      SpotlightFeedback.main(Array[String]())
    }
  }
}